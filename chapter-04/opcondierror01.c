//#include <stdio.h>
//
//int main(void)
//{
//	int nInput = 0, nSelect = 0;
//	scanf_s("%d", &nInput);
//
//	nInput <= 10 ? nSelect = 10 : nSelect = 20;
//	printf("%d\n", nSelect);
//
//	nInput <= 10 ? (nSelect = 10) : (nSelect = 20);
//	printf("%d\n", nSelect);
//
//	return 0;
//}
//
///*
//문제가 있는 부분은 8번 행. 그리고 그 문제를 해결한 것이 11번 행. 여기서 문제라고하는 것은 컴파일 오류를 말하는 것인데, 많은 사람이 단순대입 연산식을 한 덩어리로 취급해버리는 잘못된 판단 때문에 이런 오류가 발생. 더 큰 문제는 이 오류에 대한 컴파일러의 에러 메시지가 엉뚱하게도 'l-value' 오류라는 것.
//대부분 이 메시지만으로는 정확한 원인 짐작 못 함. 그러나 8번 행을 다음과 같이 변경(세 번째 피연산자 코드 수정)한 후 빌드하면 아무런 오류 발생 안 함. 이를 통해 원인 파악 가능.
//nInput <= 10 ? nSelect = 10 : nSelect;
//
//이 코드 조각의 연산결과는 참이든 거짓이든 결국은 'nSelect' 변수. 조건이 참이면 nSelect 변수에 10을 대입한 후 nSelect 변수에 저장된 값을 선택하고 거짓이면 현재 nSelect에 저장된 값을 선택.
//그리고 이 코드에 앞에서처럼 20을 단순 대입하는 코드가 추가되면 'nSelect = 20'이 아니라 nSelect에 저장된 정보에 20을 대입하라는 연산이 됨. 즉, nSelect 변수에 들어있는 값이 100이라면 '100 = 20'이라는 코드를 실행하는 것과 같다. l-value 오류가 발생한 것은 이 때문.
//
//sizeof 연산이나 주소 연산자(&) 같은 컴파일 타임 연산 제외, 연산에 참여하는 피연산자는 변수 그 자체가 아니라 그 안에 담긴 값입니다.
//*/